---
title: 자료구조 - 1
link: data_structure_1
date: 2024-09-14
tags:
  - CS
coverImage: 'https://velog.velcdn.com/images/pul8219/post/3f32ad5e-3065-495b-b60a-09fd396a3b34/algorithm_dataStructure.png'
ogImage: 'https://velog.velcdn.com/images/pul8219/post/3f32ad5e-3065-495b-b60a-09fd396a3b34/algorithm_dataStructure.png'
---

# 목표

기술 면접에서 자료구조에 대한 질문을 받았을 때, 자신있게 대답 하지 못하는 걸 보고 공부를 시작했습니다. <br/>
이걸 계기로 자료구조에 대해 자료구조에 대한 기본적인 개념과 종류, 각각의 특징을 알아보고자 합니다. <br/>

# 자료구조(Data Structure)

## 자료구조란?

> 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장등을 의미합니다.

데이터의 특성과 크기, 주요 사용법에 따라 여러가지 종류의 자료구조 중 하나를 선택할 수 있습니다. <br/>
자료구조의 종류로는 자료형에 따라 분류하는 기본 자료구조와 추상적 자료구조로 나눌 수 있습니다.

## 자료구조의 종류

자료구조는 단순 자료구조(primitive data structure)와 복합 자료구조(composite data structure)로 나눌 수 있습니다. <br/>
단순 자료구조는 int, float, char 등의 기본 데이터 타입을 의미하며, 복합 자료구조는 여러 개의 단순 자료구조를 조합한 것을 의미합니다. <br/>

<br/>

복합 자료구조는 다시 선형 자료구조와 비선형 자료구조로 나눌 수 있습니다. <br/>
선형 자료구조 에는 배열, 연결 리스트, 스택, 큐, 해시 테이블 등이 있으며, 비선형 자료구조에는 트리, 그래프, 트라이, 집합, 맵 등이 있습니다.

### 1. 선형 자료구조

데이터 요소들이 선형적으로 배열되어 있는 자료구조입니다. 데이터 요소들은 순차적으로 연결되어 있습니다.

- 배열(Array)
- 연결 리스트(Linked List)
- 스택(Stack)
- 큐(Queue)

### 2. 비선형 자료구조

좀 더 복잡한 연산을 수행할 수 있는 자료구조입니다. 기본 자료구조를 바탕으로 구현됩니다.

- 해시 테이블(Hash Table)
- 트리(Tree)
- 그래프(Graph)
- 트라이(Trie)
- 집합(Set)
- 맵(Map)

## 선형 자료구조

### 1) 배열(Array)

배열은 동일한 타입의 데이터들을 저장하고 고정된 크기를 가지며, 메모리의 물리적인 순서를 통해 인덱스가 부여됩니다.
배열에 저장된 데이터는 인덱스를 통해 접근할 수 있습니다. <br/>
![](https://velog.velcdn.com/images/r_eum/post/945ffce2-9d21-40ed-9dea-9a1ae6d0a48c/image.png)
배열은 다른 데이터 구조를 구축하기 위한 블록으로 사용되며, 정렬에 용이하지만 구조를 재구성하는데 어려움이 있습니다.

<br/>

### 2) 연결 리스트(Linked List)

연결 리스트는 데이터 요소들을 노드라는 객체로 구성하며, 노드는 데이터와 다음 노드에 대한 참조로 구성됩니다.
인덱스가 아닌 참조를 통해 순차적으로 연결되는 구조입니다. <br/>
첫 번째 요소를 참조하는 **head**, 마지막 요소를 참조하는 **tail**이 있습니다. <br/>
![](https://velog.velcdn.com/images/r_eum/post/9bc5df9f-ef4d-4b88-b99c-124f92355d67/image.png)
리스트는 데이터의 추가 및 삭제시 구조를 재구성할 필요가 없이 참조만 변경하면 되기 때문에 동적인
메모리 할당에 용이합니다. 하지만 배열보다 메모리 사용량이 더 많고, 데이터를 찾기위해 순차적으로 탐색해야 하는 단점이 있습니다.

<br/>

### 3) 스택(Stack)

스택은 배열이나 리스트로 구성되어 순서가 보존되는 선형 데이터 구조이며,
마지막에 입력된 데이터부터 처리하는 후입선출(Last In First Out, LIFO) 메커니즘을 가집니다.
스택의 맨 위를 가리키는 레지스터를 스택 포인터라고 합니다. 스택 맨 위의 현재 위치를 추적하는데 사용됩니다.
스택은 용량으로 특정지어지는데, 이는 주어진 시간에 보유할 수 있는 데이터의 수를 제한합니다. <br/>
요소를 전체 스택에 푸시하려고 하면 스택 오버플로우가 발생합니다. <br/>
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221219100314/stack.drawio2.png)
스택은 수학적 표현식을 분석하거나 재귀함수의 호출을 구현하는데 효율적인 구조입니다.


### 4) 큐(Queue)

큐는 선입선출(First In First Out, FIFO) 메커니즘을 가지는 선형 데이터 구조입니다.
큐는 먼저 입력된 요소가 먼저 처리되는 구조로, 요소를 추가하는 작업을 인큐(enqueue), 요소를 제거하는 작업을 디큐(dequeue)라고 합니다.
큐는 배열이나 리스트로 구현될 수 있으며, 배열로 구현된 큐는 원형 큐로 구현될 수 있습니다. <br/>

![](https://media.geeksforgeeks.org/wp-content/uploads/20240606165428/Introduction-to-Queue-(2).webp)

------

## 비선형 자료구조

### 1) 해시 테이블(Hash Table)

해시 테이블은 **(Key, Value)로 데이터를 저장하는 자료구조**중 하나로 빠르게 데이터를 검색할 수 있습니다.
해시테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 때문입니다.
각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고 이 index에 Value를 저장합니다.
실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 합니다.

<br/>

해시 함수에서 중요한 것은 고유한 인덱스 값을 설정해야 하며, 이를 위해 사용하는 방법으로는 **나눗셈, 곱셈, 더블 해싱** 등이 있습니다.

- 나눗셈(Division) : 해시 테이블의 크기로 나눈 나머지를 인덱스로 사용합니다.
- 곱셈(Multiplication) : 해시 테이블의 크기로 곱한 후 소수점 이하를 버린 값을 인덱스로 사용합니다.
- 더블 해싱(Double Hashing) : 두 개의 해시 함수를 사용하여 충돌을 해결합니다.

<br/>

해시 함수에서 해시 값이 충돌하는 경우가 발생할 수 있습니다.
이를 해결하기 위해 주로 두가지 방법을 사용합니다.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240514124239/collision-in-hashing.webp)

- 개방주소방식(Open Addressing) : 충돌이 발생하면 다른 빈 버킷을 찾아 저장합니다.
- 체이닝(Chaining) : 충돌이 발생하면 연결리스트로 연결하여 저장합니다.

<br/>

**개방주소방식**
개방 주소방식(Open Addressing)이란 추가적인 메모리를 사용하는 후술될 체이닝 방식과는 다르게
비어있는 해시테이블의 공간을 활용하는 방법입니다. 주로 선형 탐사, 이차 탐사, 이중 해싱 방법이 있습니다.

- 선형 탐사(Linear Probing) : 현재 인덱스로부터 고정폭으로 이동하여 차례대로 검색해 비어있는 공간을 찾습니다.
- 이차 탐사(Quadratic Probing) : 충돌이 발생하면 제곱수만큼 이동하여 비어있는 공간을 찾습니다.
- 이중 해싱(Double Hashing) : 해시된 값을 한번 더 해싱하여 규칙성을 없애버리는 방식입니다. 다른 방법들 보다 많은 연산을 하게됩니다.

**체이닝**
체이닝(Chaining)은 해시 충돌이 발생하면 연결리스트로 연결하여 저장하는 방식입니다.
해시 테이블의 각 버킷에 연결리스트를 저장하고, 충돌이 발생하면 해당 버킷에 연결리스트에 추가합니다.
해시 테이블의 크기가 커질수록 연결리스트의 길이가 길어지므로 성능이 저하될 수 있습니다.
